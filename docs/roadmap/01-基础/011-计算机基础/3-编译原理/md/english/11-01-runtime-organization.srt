0
00:00:03,730 --> 00:00:10,730
In this video we're going to begin our discussion of run time systems. Now, at

1
00:00:12,670 --> 00:00:17,410
this point we have actually covered the entire front end of the compiler which

2
00:00:17,410 --> 00:00:22,679
consists of the three phases, lexical analysis, parsing and semantic analysis

3
00:00:22,679 --> 00:00:28,730
And these three passes or these three phases together, their job is to really

4
00:00:28,730 --> 00:00:35,730
enforce the language semantics or the language definition. So, we know. After

5
00:00:38,629 --> 00:00:43,550
these three phases are done that if no errors have been generated by anyone of

6
00:00:43,550 --> 00:00:47,590
those phases then the program is actually a valid program in the programming

7
00:00:47,590 --> 00:00:51,829
language that we're compiling And at this point the compiler is going to be able to

8
00:00:51,829 --> 00:00:56,910
produce codes to produce a translation of the program that you can actually execute.

9
00:00:56,910 --> 00:01:00,440
And I should say that of course. Enforcing the language definition is just one

10
00:01:00,440 --> 00:01:05,210
purpose of the front-end. The front-end also builds the data structures that are

11
00:01:05,209 --> 00:01:10,720
needed to do co-generation as we seen but there is a real. Once we get through the

12
00:01:10,720 --> 00:01:15,720
front-end we no longer looking for errors in the program. We're no longer trying to

13
00:01:15,720 --> 00:01:19,660
figure out whether it's a valid program. Now we're really down to the point where

14
00:01:19,660 --> 00:01:25,970
we're going to generate code And that is a job at the back end. So cogeneration is

15
00:01:25,970 --> 00:01:30,570
certainly part of it. The other big part of the back end is program optimization so

16
00:01:30,570 --> 00:01:35,790
doing transformations to improve the program. But before we can talk about

17
00:01:35,790 --> 00:01:42,230
either one of those things, we need to talk about Runtime organization And why is

18
00:01:42,230 --> 00:01:46,630
that, well because we need to understand what it is we're trying to generate before

19
00:01:46,630 --> 00:01:50,320
we can talk about how we generated and have that makes sense. So first, we're

20
00:01:50,320 --> 00:01:54,870
gonna talk about what the, the translator program looks like and how it's organized

21
00:01:54,870 --> 00:01:57,950
and then we'll talk about algorithms and code generation algorithms were actually

22
00:01:57,950 --> 00:02:02,710
producing those things. And this is a well-understood area or at least some very

23
00:02:02,710 --> 00:02:06,080
standard techniques that are widely used and those are the ones we wanted to cover

24
00:02:06,080 --> 00:02:13,080
and, and encourage you to use in your project. The main thing we're going to

25
00:02:14,629 --> 00:02:19,489
cover in this sequence of videos is the management of Runtime resources and in

26
00:02:19,489 --> 00:02:24,310
particular I'm going to be stressing the correspondence and the distinction between

27
00:02:24,310 --> 00:02:29,879
static and dynamic structures. So static structures are things that exist to

28
00:02:29,879 --> 00:02:35,099
compile time and dynamic structures, those are the things that exist or happen at

29
00:02:35,099 --> 00:02:42,099
Runtime And, this is probably the most important distinction for you to try to

30
00:02:42,120 --> 00:02:45,930
understand if you really want to understand how a compiler works. What

31
00:02:45,930 --> 00:02:49,569
happens to the compile time and what happens at run time. Having a clear

32
00:02:49,569 --> 00:02:55,140
separation in your mind between what is done by the compiler and what is deferred

33
00:02:55,140 --> 00:02:59,709
to when the target program or the generated program actually runs that is

34
00:02:59,709 --> 00:03:05,819
key to really understanding how compilers work. And we'll also be talking about

35
00:03:05,819 --> 00:03:10,670
storage organization. So how memory is used to store the data structures of the

36
00:03:10,670 --> 00:03:17,670
executing program. So let's begin at the beginning. So initially there is the

37
00:03:19,310 --> 00:03:22,230
operating system and the operating system is the only thing that is running on the

38
00:03:22,230 --> 00:03:27,670
machine and when a program is invoke. When the user says he wants to run a program,

39
00:03:27,670 --> 00:03:32,370
what happens while the operating system is going to allocate space for the program

40
00:03:32,370 --> 00:03:37,819
the code for the program is going to be loaded into that space and then the

41
00:03:37,819 --> 00:03:42,499
operating system is going to execute a job to the entry point or the main function of

42
00:03:42,499 --> 00:03:49,349
the program and then your program will be off and running. So, let's take a look at

43
00:03:49,349 --> 00:03:54,200
what the organization memory looks like very roughly when the Operating System

44
00:03:54,200 --> 00:03:59,480
began execution of the compiled program. So we're gonna draw our pictures of memory

45
00:03:59,480 --> 00:04:04,859
like this. That would be just a big block and there will be a starting address at

46
00:04:04,859 --> 00:04:08,969
the, a lower address and a higher address and this is all the memory that is

47
00:04:08,969 --> 00:04:14,799
allocated to your program. Now into some portion of that space goes to code for the

48
00:04:14,799 --> 00:04:20,060
program so the actual compiled code for the program is loaded usually at one end

49
00:04:20,060 --> 00:04:25,320
of the memory space allocated to the program. And then there is a bunch. Of

50
00:04:25,320 --> 00:04:29,850
other space that is going to be used for other things and we'll talk about that in

51
00:04:29,850 --> 00:04:36,470
a minute. Before going on, I want to say a few words about this pictures of Run-time

52
00:04:36,470 --> 00:04:40,840
Organization because I'm going to be drawing a lot of them over the next few

53
00:04:40,840 --> 00:04:47,210
videos. So, it's just traditional to have memory drawn as a rectangle with the low

54
00:04:47,210 --> 00:04:52,340
address at the top and the high address at the bottom. There's nothing magic about

55
00:04:52,340 --> 00:04:55,620
that, just a convention we could adjust it easily every verse or order of the

56
00:04:55,620 --> 00:05:01,370
address, no big deal. And then we'll be drawing lines to the limit different

57
00:05:01,370 --> 00:05:07,530
regions of this memory showing different kinds of data and how they're stored in

58
00:05:07,530 --> 00:05:12,370
the memory allocated to the program. And clearly these pictures are simplifications

59
00:05:12,370 --> 00:05:17,450
if this, is a virtual memory system for example, there's no guarantee that these

60
00:05:17,450 --> 00:05:23,370
data is actually laid out contiguously but it helps to understand you know, what the

61
00:05:23,370 --> 00:05:29,500
different kinds of data are. And what the, a compiler needs to do with them to have

62
00:05:29,500 --> 00:05:36,500
simple pictures like this. So coming back to our picture of run time organization,

63
00:05:37,580 --> 00:05:43,350
we have some block memory and the first portion of that is occupied by the actual

64
00:05:43,350 --> 00:05:46,970
generated code for the program and then there was this other space and we're what

65
00:05:46,970 --> 00:05:51,930
goes to that space? Well, what goes to that space is the data for the program. So

66
00:05:51,930 --> 00:05:57,520
all the data is in the rest of the space and the tricky thing about code generation

67
00:05:57,520 --> 00:06:01,870
that the compiler is responsible for generating the code but it's also

68
00:06:01,870 --> 00:06:06,620
responsible for orchestrating the data. So the compiler has to decide what the lay of

69
00:06:06,620 --> 00:06:11,530
the data is going to be and then generate code that correctly manipulates that data

70
00:06:11,530 --> 00:06:16,810
so there are references of course in the code. To the data and the code and data

71
00:06:16,810 --> 00:06:20,500
need to be designed, the code and the layout of the data, excuse me, need to be

72
00:06:20,500 --> 00:06:26,580
designed together so that the generated program will function correctly. Now, it

73
00:06:26,580 --> 00:06:31,870
turns out that this actually more than one kind of data that the compiler is going to

74
00:06:31,870 --> 00:06:36,520
be interested in and what we'll be talking about. In the next video is the different

75
00:06:36,520 --> 00:06:39,440
kinds of data and the different distinction between the kinds of data that

76
00:06:39,440 --> 00:06:41,490
go in this data area.
